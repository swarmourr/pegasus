/**
 * Copyright 2007-2021 University Of Southern California
 *
 * <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * <p>http://www.apache.org/licenses/LICENSE-2.0
 *
 * <p>Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.isi.pegasus.planner.transfer.generator;

import static edu.isi.pegasus.planner.refiner.TransferEngine.REFINER_NAME;

import edu.isi.pegasus.common.logging.LogManager;
import edu.isi.pegasus.common.util.PegasusURL;
import edu.isi.pegasus.planner.catalog.replica.ReplicaCatalogEntry;
import edu.isi.pegasus.planner.catalog.site.classes.FileServer;
import edu.isi.pegasus.planner.catalog.site.classes.FileServerType;
import edu.isi.pegasus.planner.catalog.site.classes.SiteCatalogEntry;
import edu.isi.pegasus.planner.classes.ADag;
import edu.isi.pegasus.planner.classes.DAXJob;
import edu.isi.pegasus.planner.classes.FileTransfer;
import edu.isi.pegasus.planner.classes.Job;
import edu.isi.pegasus.planner.classes.NameValue;
import edu.isi.pegasus.planner.classes.PegasusBag;
import edu.isi.pegasus.planner.classes.PegasusFile;
import edu.isi.pegasus.planner.classes.PlannerOptions;
import edu.isi.pegasus.planner.classes.ReplicaLocation;
import edu.isi.pegasus.planner.common.PegasusProperties;
import edu.isi.pegasus.planner.mapper.OutputMapper;
import edu.isi.pegasus.planner.mapper.OutputMapperFactory;
import edu.isi.pegasus.planner.mapper.output.Replica;
import edu.isi.pegasus.planner.namespace.Pegasus;
import edu.isi.pegasus.planner.refiner.ReplicaCatalogBridge;
import edu.isi.pegasus.planner.selector.ReplicaSelector;
import edu.isi.pegasus.planner.transfer.Refiner;
import java.io.File;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;

/**
 * This class determines where the outputs generated by a job need to be placed It computes
 * FileTransfer pairs that contain both the source URL on the staging site and the destination URL
 * on the output site. Internally the StageOut Placer relies on OutputMapper to find the destination
 * URL on the output site. It also groups File Transfers as transfers that - need to be managed
 * locally (third party mode) IR - remotely (case where the staging site only has file accessible
 * URLs)
 *
 * @author Karan Vahi
 */
public class StageOut extends Abstract {

    /**
     * Handle to an OutputMapper that tells where to place the files on the output sites. this
     * output mapper is the one configured by the user via properties
     */
    private OutputMapper mOutputMapper;

    /**
     * Handle to an OutputMapper that tells where to place the files on the scratch file system for
     * compute jobs in the parent workflow (the workflow in which there is a DAX job that triggers
     * the execution of the workflow currently planned as part of the pre script) This output mapper
     * is the one set on the command line by Pegasus in case of hierarchal workflows.
     */
    private OutputMapper mParentScratchOutputMapper;

    public StageOut() {}

    /**
     * Initializes the Stageout generator
     *
     * @param dag the workflow so far.
     * @param bag bag of initialization objects
     * @param transferRefiner the transfer refiner being used
     */
    public void initalize(ADag dag, PegasusBag bag, Refiner transferRefiner) {
        super.initalize(dag, bag, transferRefiner);
        mOutputMapper = OutputMapperFactory.loadInstance(dag, bag);

        // PM-1608 load a mapper if required
        mParentScratchOutputMapper = getParentWFScratchMapper(dag, bag);
        mLogger.log(
                "Output Mapper loaded is              [" + mOutputMapper.description() + "]",
                LogManager.CONFIG_MESSAGE_LEVEL);
        if (mParentScratchOutputMapper != null) {
            mLogger.log(
                    "Output Scratch Mapper loaded is      ["
                            + mParentScratchOutputMapper.description()
                            + "]",
                    LogManager.CONFIG_MESSAGE_LEVEL);
        }
    }

    /**
     * Returns an output mapper responsible for transferring some outputs to the scratch file system
     * of the enclosing parent workflow.
     *
     * @param dag
     * @param bag
     * @return
     */
    private OutputMapper getParentWFScratchMapper(ADag dag, PegasusBag bag) {
        PlannerOptions options = bag.getPlannerOptions();
        String mapFile = options.getOutputMap();
        if (mapFile == null) {
            return null;
        }

        String key = OutputMapperFactory.PROPERTY_KEY;

        // PM-1608 always load a replica based output mapper corresponding to this file
        PegasusProperties props = PegasusProperties.nonSingletonInstance();

        // PM-1795 see if any mapper properties are set in System.properties that
        // always have highest precedence and mess up the factory loading. For
        // example a mapper property mentioned on the command line
        Properties mapperSystemProperties = props.matchingSubsetFromSystemProperties(key);
        mapperSystemProperties.forEach(
                (k, v) -> {
                    mLogger.log(
                            "Removing temporarily System property " + k,
                            LogManager.DEBUG_MESSAGE_LEVEL);
                    props.removeSystemProperty((String) k);
                });

        props.setProperty(key, "Replica");
        // output map file is a file based rc
        key += ".replica";
        props.setProperty(key, "File");
        // set path to output mapper
        props.setProperty(key + ".file", mapFile);
        // disable execption thrown by mapper
        props.setProperty(key + "." + Replica.DISABLE_EXCEPTIONS_KEY, "true");

        PegasusBag b = new PegasusBag();
        b.add(PegasusBag.PLANNER_OPTIONS, options);
        b.add(PegasusBag.PEGASUS_LOGMANAGER, bag.getLogger());
        b.add(PegasusBag.PEGASUS_PROPERTIES, props);

        OutputMapper result = OutputMapperFactory.loadInstance(dag, b);

        // PM-1795 set back any system properties
        mapperSystemProperties.forEach(
                (k, v) -> {
                    mLogger.log(
                            "Adding back System property " + k + "->" + v,
                            LogManager.DEBUG_MESSAGE_LEVEL);
                    props.setSystemProperty((String) k, (String) v);
                });
        return result;
    }
    /**
     * This gets the file transfer objects corresponding to the location of files found in the
     * replica mechanism, and transfers it to the output site asked by the user. If the output site
     * path and the one returned by the replica mechanism match then that object is not transferred.
     *
     * @param rcBridge ReplicaCatalogBridge
     * @param replicaSelector the replica selector
     * @param job The Job object corresponding to the leaf job which was deleted by the Reduction
     *     algorithm
     * @param destSite this the output site which the user specifies at runtime.
     * @return Collection of <code>FileTransfer</code> objects
     */
    public Collection<FileTransfer> constructDeletedFileTX(
            ReplicaCatalogBridge rcBridge,
            ReplicaSelector replicaSelector,
            Job job,
            String destSite) {

        Collection<FileTransfer> fileTransfers = new LinkedList();
        SiteCatalogEntry outputSite = mSiteStore.lookup(destSite);
        for (Iterator it = job.getOutputFiles().iterator(); it.hasNext(); ) {
            PegasusFile pf = (PegasusFile) it.next();
            String lfn = pf.getLFN();

            // PM-739 all output files for deleted jobs should have their
            // cleanup flag set to false. these output files are not
            // generated during the workflow, but are retrieved from a
            // location specified in the replica catalog.
            pf.setForCleanup(false);

            // we only have to get a deleted file that user wants to be transferred
            if (pf.getTransientTransferFlag()) {
                continue;
            }

            ReplicaLocation rl = rcBridge.getFileLocs(lfn);
            // sanity check
            if (rl == null) {
                throw new RuntimeException(
                        "Unable to find a physical filename (PFN) in the Replica Catalog for output file with logical filename (LFN) as "
                                + lfn);
            }

            String putDestURL =
                    mOutputMapper.map(lfn, destSite, FileServer.OPERATION.put).getValue();
            String getDestURL =
                    mOutputMapper.map(lfn, destSite, FileServer.OPERATION.get).getValue();

            // selLocs are all the locations found in ReplicaMechanism corr
            // to the site site
            ReplicaLocation selLocs =
                    replicaSelector.selectAndOrderReplicas(
                            rl,
                            destSite,
                            mTransferJobPlacer.runTransferOnLocalSite(
                                    outputSite, putDestURL, Job.STAGE_OUT_JOB));

            boolean flag = false;

            FileTransfer ft = null;
            // checking through all the pfn's returned on the site
            for (Iterator selIt = selLocs.pfnIterator(); selIt.hasNext(); ) {
                ReplicaCatalogEntry selLoc = (ReplicaCatalogEntry) selIt.next();
                String sourceURL = selLoc.getPFN();

                // check if the URL's match
                if (new PegasusURL(sourceURL).equals(new PegasusURL(putDestURL))) {
                    String msg =
                            "The leaf file " + lfn + " is already at the output site " + destSite;
                    mLogger.log(msg, LogManager.INFO_MESSAGE_LEVEL);
                    flag = true;
                    break;
                }

                ft = new FileTransfer(lfn, job.getName());
                ft.addSource(selLoc.getResourceHandle(), sourceURL);
                ft.addDestination(destSite, putDestURL);
                ft.setURLForRegistrationOnDestination(getDestURL);
                ft.setSize(pf.getSize());
                ft.setForCleanup(false); // PM-739

                // System.out.println("Deleted Leaf Job File transfer object " + ft);

            }
            if (!flag) { //  adding the last pfn
                fileTransfers.add(ft);
            }
        }
        return fileTransfers;
    }

    /**
     * This determines where output files for a job should be placed on an output site If the
     * transfer transient flag is set, it means the file does not have to be transferred to the
     * output site.
     *
     * @param job The <code>Job</code>object of the job whose output files are needed at the
     *     destination site.
     * @param destSiteHandle The site to which the files are to be transferred to.
     * @return array of Collection of <code>FileTransfer</code> objects, with the first Collection
     *     referring to transfers that need to happen on submit node, and the second Collection
     *     referring to transfers that need to happen on destination node
     */
    public Collection<FileTransfer>[] constructFileTX(Job job, String destSiteHandle) {
        Collection<FileTransfer>[] result = new Collection[2];
        result[0] = new LinkedList(); // local transfers
        result[1] = new LinkedList(); // remote transfers

        // sanity check on staging site once per job
        SiteCatalogEntry stagingSite = mSiteStore.lookup(job.getStagingSiteHandle());
        if (stagingSite == null) {
            mLogMsg = this.siteNotFoundMsg(job.getSiteHandle(), "vanilla");
            mLogger.log(mLogMsg, LogManager.ERROR_MESSAGE_LEVEL);
            throw new RuntimeException(mLogMsg);
        }

        // PM-590 Stricter checks
        String stagingSiteURLPrefix =
                stagingSite.selectHeadNodeScratchSharedFileServerURLPrefix(
                        FileServer.OPERATION.get);
        if (stagingSiteURLPrefix == null) {
            this.complainForHeadNodeURLPrefix(
                    REFINER_NAME, stagingSite.getSiteHandle(), FileServer.OPERATION.get, job);
        }

        // check if there is a remote initialdir set
        String path = job.vdsNS.getStringValue(Pegasus.REMOTE_INITIALDIR_KEY);

        for (Iterator it = job.getOutputFiles().iterator(); it.hasNext(); ) {
            PegasusFile pf = (PegasusFile) it.next();
            if (destSiteHandle == null) {
                // PM-1608 construct file transfers to parent workflow scratch
                // directories
                // specified via --output-map option . can return multiple locations
                // from the output map file
                result = this.constructFileTXToParentWFScratchDirs(pf, job, path);
            } else {
                // construct file transfer to output site
                NameValue<Boolean, FileTransfer> transfer =
                        this.constructFileTX(pf, job, destSiteHandle, path);
                if (transfer != null) {
                    boolean localTransfer = transfer.getKey();
                    if (localTransfer) {
                        result[0].add(transfer.getValue());
                    } else {
                        result[1].add(transfer.getValue());
                    }
                }
            }

            Collection<FileTransfer> fts = new LinkedList();
            // add all local and remote file transfers to a temp collection to be updated once
            fts.addAll(result[0]);
            fts.addAll(result[1]);

            for (FileTransfer ft : fts) {
                if (this.mDoIntegrityChecking
                        && this.mPegasusConfiguration.jobSetupForWorkerNodeExecution(job)) {
                    // PM-1252 for files generated in the workflow , the checksum will be
                    // computed
                    // in the PegasusLite invocation
                    ft.setChecksumComputedInWF(true);

                    // PM-1254 disable for time being for checkpoint files
                    if (ft.isCheckpointFile()) {
                        ft.setChecksumComputedInWF(false);
                    }

                    // PM-1608 disable integrity checking for files that transferred out of a
                    // sub workflow as we don't transfer any meta files from the sub workflow
                    if (job instanceof DAXJob) {
                        ft.setChecksumComputedInWF(false);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Constructs the FileTransfer object on the basis of the transiency information. If the
     * transient flag for transfer is set, the destPutURL for the FileTransfer object would be the
     * execution directory, as this is the entry that has to be registered in the ReplicaMechanism
     *
     * @param pf the PegasusFile for which the transfer has to be done.
     * @param job the name of the associated job.
     * @param destSiteHandle the output site where the job should be transferred
     * @param path the path that a user specifies in the profile for key remote_initialdir that
     *     results in the workdir being changed for a job on a execution site.
     * @return NameValue tuple that associates a boolean indicating whether transfer has to run on
     *     submit site for the corresponding FileTransfer object. A null return indicates no
     *     FileTransfer object needed to be created
     */
    private NameValue<Boolean, FileTransfer> constructFileTX(
            PegasusFile pf, Job job, String destSiteHandle, String path) {

        String stagingSiteHandle = job.getStagingSiteHandle();
        String lfn = pf.getLFN();
        FileTransfer ft = null;

        SiteCatalogEntry stagingSite = mSiteStore.lookup(stagingSiteHandle);
        SiteCatalogEntry destinationSite = mSiteStore.lookup(destSiteHandle);
        if (stagingSite == null || destinationSite == null) {
            mLogMsg =
                    (stagingSite == null)
                            ? this.siteNotFoundMsg(stagingSiteHandle, "vanilla")
                            : this.siteNotFoundMsg(destSiteHandle, "vanilla");
            mLogger.log(mLogMsg, LogManager.ERROR_MESSAGE_LEVEL);
            throw new RuntimeException(mLogMsg);
        }

        // PM-833 figure out the addOn component just once per lfn
        File addOn = mStagingMapper.mapToRelativeDirectory(job, stagingSite, lfn);

        // the get
        String sharedScratchGetURL =
                this.getURLOnSharedScratch(
                        stagingSite, job, FileServerType.OPERATION.get, addOn, lfn);

        // if both transfer and registration
        // are transient return null
        if (pf.getTransientRegFlag() && pf.getTransientTransferFlag()) {
            // an output file has both register and stageOut flags to false
            return null;
        }

        // if only transient transfer flag
        // means destPutURL and sourceURL
        // are same and are equal to
        // execution directory on stagingSiteHandle
        if (pf.getTransientTransferFlag()) {
            // need to support this, as user may still opt for the file to be
            // registered in the replica catalog.
            ft = new FileTransfer(lfn, job.getID(), pf.getFlags());
            // set the transfer mode
            ft.setSize(pf.getSize());
            ft.setTransferFlag(pf.getTransferFlag());
            ft.addSource(stagingSiteHandle, sharedScratchGetURL);
            ft.addDestination(stagingSiteHandle, sharedScratchGetURL);
            ft.setURLForRegistrationOnDestination(sharedScratchGetURL);
            ft.setMetadata(pf.getAllMetadata());
            ft.setType(pf.getType());
            return new NameValue<>(true, ft);
        }
        // the source dir is the exec dir
        // on exec site and dest dir
        // would be on the output site
        // else {
        ft = new FileTransfer(lfn, job.getID(), pf.getFlags());
        ft.setSize(pf.getSize());
        // set the transfer mode
        ft.setTransferFlag(pf.getTransferFlag());

        /* PM-1779 not supported in new 5.0 schema. so removing code
        ft.addSource(stagingSiteHandle, sourceURL);

        // if the PegasusFile is already an instance of
        // FileTransfer the user has specified the destination
        // that they want to use in the DAX 3.0
        if (pf instanceof FileTransfer) {
            // not really supported in DAX 3.3?
            ft.addDestination( ((FileTransfer) pf).removeDestURL() );
            return ft;
        }
        */

        ft.setMetadata(pf.getAllMetadata());
        ft.setType(pf.getType());

        boolean localTransfer = true;
        for (NameValue<String, String> nv :
                this.mOutputMapper.mapAll(lfn, destSiteHandle, FileServerType.OPERATION.put)) {
            String destURL = nv.getValue();
            localTransfer =
                    mTransferJobPlacer.runTransferOnLocalSite(
                            stagingSite, sharedScratchGetURL, Job.STAGE_OUT_JOB);
            // construct the source url depending on whether third party tx
            String sourceURL = sharedScratchGetURL;
            if (!localTransfer) {
                // job will be run remotely. So pick file URL path
                sourceURL =
                        constructFileURLToStagingSiteDirectory(stagingSiteHandle, path, addOn, lfn);
            }
            ft.addSource(stagingSiteHandle, sourceURL);

            // if the paths match of dest URI
            // and execDirURL we return null
            if (sharedScratchGetURL.equalsIgnoreCase(destURL)) {
                /*ft = new FileTransfer(file, job);
                ft.addSource(stagingSiteHandle, sharedScratchGetURL);*/
                ft.addDestination(stagingSiteHandle, sharedScratchGetURL);
                ft.setURLForRegistrationOnDestination(sharedScratchGetURL);
                // make the transfer transient?
                ft.setTransferFlag(PegasusFile.TRANSFER_NOT);
                return new NameValue<Boolean, FileTransfer>(localTransfer, ft);
            }
            ft.addDestination(destSiteHandle, destURL);
        }

        // construct a registration URL
        ft.setURLForRegistrationOnDestination(
                mOutputMapper.map(lfn, destSiteHandle, FileServer.OPERATION.get, true).getValue());

        if (job instanceof DAXJob) {
            // PM-1608 if the dax job itself wants to transfer the output
            // then we log the put URL of the shared scratch in the output map
            // so that when sub workflow runs, it can put the file to the source
            // location required for this file transfer
            FileTransfer scratchPutFT = new FileTransfer();
            scratchPutFT.setLFN(lfn);
            String sharedScratchPutURL =
                    this.getURLOnSharedScratch(
                            stagingSite, job, FileServerType.OPERATION.put, addOn, lfn);
            scratchPutFT.addDestination(stagingSiteHandle, sharedScratchPutURL);
            ((DAXJob) job).addOutputFileLocation(mBag, scratchPutFT);
        }
        // }

        return new NameValue<>(localTransfer, ft);
    }

    /**
     * Constructs the FileTransfer to transfer outputs to enclosing parent workflow scratch
     * directory, if the file is found in the corresponding output map file.
     *
     * @param pf the PegasusFile for which the transfer has to be done.
     * @param job the name of the associated job.
     * @param path the path that a user specifies in the profile for key remote_initialdir that
     *     results in the workdir being changed for a job on a execution site.
     * @return array of Collection of <code>FileTransfer</code> objects, with the first Collection
     *     referring to transfers that need to happen on submit node, and the second Collection
     *     referring to transfers that need to happen on destination node
     */
    private Collection<FileTransfer>[] constructFileTXToParentWFScratchDirs(
            PegasusFile pf, Job job, String path) {
        String stagingSiteHandle = job.getStagingSiteHandle();
        String lfn = pf.getLFN();
        FileTransfer ft = null;
        Collection<FileTransfer>[] result = new Collection[2];
        result[0] = new LinkedList(); // local transfers
        result[1] = new LinkedList(); // remote transfers
        // variables for code readability
        Collection<FileTransfer> localTransfers = result[0];
        Collection<FileTransfer> remoteTransfers = result[1];

        // List<FileTransfer> result = new LinkedList<FileTransfer>();
        SiteCatalogEntry stagingSite = mSiteStore.lookup(stagingSiteHandle);
        if (stagingSite == null) {
            mLogMsg = this.siteNotFoundMsg(stagingSiteHandle, "vanilla");
            mLogger.log(mLogMsg, LogManager.ERROR_MESSAGE_LEVEL);
            throw new RuntimeException(mLogMsg);
        }

        // PM-833 figure out the addOn component just once per lfn
        File addOn = mStagingMapper.mapToRelativeDirectory(job, stagingSite, lfn);

        // the get
        String sharedScratchGetURL =
                this.getURLOnSharedScratch(
                        stagingSite, job, FileServerType.OPERATION.get, addOn, lfn);

        List<NameValue<String, String>> nvs =
                this.mParentScratchOutputMapper.mapAll(lfn, null, FileServerType.OPERATION.put);
        if (nvs == null) {
            return result;
        }
        for (NameValue<String, String> nv : nvs) {
            ft = new FileTransfer(lfn, job.getID(), pf.getFlags());
            // we are only transferring outputs to the scratch dir of parent workflow
            // without registering them ever
            ft.setTransferFlag(true);
            ft.setRegisterFlag(false);
            ft.setMetadata(pf.getAllMetadata());
            ft.setType(pf.getType());
            String destSiteHandle = nv.getKey();
            String destURL = nv.getValue();
            /*
            SiteCatalogEntry destinationSite = mSiteStore.lookup(destSiteHandle);
            if (destinationSite == null) {
                mLogger.log(
                        this.siteNotFoundMsg(destSiteHandle, "vanilla"),
                        LogManager.ERROR_MESSAGE_LEVEL);
                throw new RuntimeException(mLogMsg);
            }
            */
            boolean localTransfer =
                    mTransferJobPlacer.runTransferOnLocalSite(
                            stagingSite, sharedScratchGetURL, Job.STAGE_OUT_JOB);

            // construct the source url depending on whether third party tx
            String sourceURL = sharedScratchGetURL;
            if (!localTransfer) {
                // job will be run remotely. So pick file URL path
                sourceURL =
                        constructFileURLToStagingSiteDirectory(stagingSiteHandle, path, addOn, lfn);
            }
            ft.addSource(stagingSiteHandle, sourceURL);

            // if the paths match of dest URI
            // and execDirURL we return null
            if (sharedScratchGetURL.equalsIgnoreCase(destURL)) {
                ft.addDestination(stagingSiteHandle, sharedScratchGetURL);
                ft.setURLForRegistrationOnDestination(sharedScratchGetURL);
                // make the transfer transient?
                ft.setTransferFlag(PegasusFile.TRANSFER_NOT);
            } else {
                ft.addDestination(destSiteHandle, destURL);
            }
            if (localTransfer) {
                localTransfers.add(ft);
            } else {
                remoteTransfers.add(ft);
            }
        }

        // reassign back to account for a new linked list that might have been
        // created during the function
        result[0] = localTransfers;
        result[1] = remoteTransfers;
        return result;
    }

    /**
     * A convenience method to create a file URL to a file in scratch directory on the staging site
     *
     * @param stagingSiteHandle the staging site handle
     * @param path the scratch dir path to the root directory for the workflow
     * @param addOn the lfn specific addon
     * @param lfn the lfn itself
     * @return a file url constructed from these
     */
    private String constructFileURLToStagingSiteDirectory(
            String stagingSiteHandle, String path, File addOn, String lfn) {
        // job will be run remotely. So pick file URL path
        StringBuilder url = new StringBuilder();
        url.append("file://")
                .append(mSiteStore.getInternalWorkDirectory(stagingSiteHandle, path))
                .append(File.separator)
                .append(addOn)
                .append(File.separator)
                .append(lfn);
        return url.toString();
    }
}
